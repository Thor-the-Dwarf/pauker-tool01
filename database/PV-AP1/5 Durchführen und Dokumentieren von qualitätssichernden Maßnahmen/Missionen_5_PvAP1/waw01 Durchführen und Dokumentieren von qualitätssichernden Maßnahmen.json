{
  "game_type": "what_and_why",
  "title": "What & Why – Kriterien der Softwarequalität",
  "description": "Schritt 1: Passendes Qualitätskriterium wählen (What) · Schritt 2: Zutreffende Begründungen markieren (Why).",
  "cases": [
    {
      "id": "c01",
      "profile": "Ein Ticketsystem soll genau die geforderten Aufgaben können: Tickets anlegen, kategorisieren, zuweisen, suchen, priorisieren und Reports erzeugen. Stakeholder prüfen, ob alle Anforderungen korrekt umgesetzt wurden.",
      "tags": ["Funktionalität", "Anforderungen", "Abnahme"],
      "options": [
        {
          "id": "funktionalitaet",
          "label": "Funktionalität",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Es geht darum, ob die Software die geforderten Funktionen korrekt bereitstellt.", "correct": true },
            { "id": "w2", "text": "Abgleich gegen Anforderungen/Use-Cases ist typisch für Funktionalität.", "correct": true },
            { "id": "w3", "text": "Es geht primär um Performance pro Request und CPU-Auslastung.", "correct": false },
            { "id": "w4", "text": "Fehlende oder falsche Features sind Funktionalitätsmängel.", "correct": true }
          ]
        },
        {
          "id": "effizienz",
          "label": "Effizienz",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Effizienz betrifft Ressourcenverbrauch und Leistungsfähigkeit (Zeit, CPU, RAM).", "correct": true },
            { "id": "w2", "text": "Effizienz bedeutet, dass die richtigen Features vorhanden sind.", "correct": false },
            { "id": "w3", "text": "Eine Funktion kann korrekt sein, aber ineffizient implementiert (langsam/teuer).", "correct": true },
            { "id": "w4", "text": "Effizienz wird oft über Antwortzeiten und Ressourcenauslastung bewertet.", "correct": true }
          ]
        }
      ],
      "solution": "Funktionalität: Erfüllt die Software die geforderten Funktionen korrekt (Abgleich gegen Anforderungen)?"
    },
    {
      "id": "c02",
      "profile": "Ein Onlineshop fällt regelmäßig aus, Bestellungen brechen ab und gelegentlich gehen Daten verloren. Das Team muss erreichen, dass der Dienst stabil läuft, Fehler selten sind und das System auch unter Last verlässlich arbeitet.",
      "tags": ["Zuverlässigkeit", "Stabilität", "Ausfälle"],
      "options": [
        {
          "id": "zuverlaessigkeit",
          "label": "Zuverlässigkeit",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Zuverlässigkeit beschreibt Stabilität, Fehlerrate und Verfügbarkeit im Betrieb.", "correct": true },
            { "id": "w2", "text": "Ausfälle, Abstürze und Datenverlust sind typische Zuverlässigkeitsprobleme.", "correct": true },
            { "id": "w3", "text": "Es geht primär um Bedienkomfort und Lernbarkeit der Oberfläche.", "correct": false },
            { "id": "w4", "text": "Maßnahmen sind z. B. Monitoring, Fehlerbehandlung, Redundanz und Tests.", "correct": true }
          ]
        },
        {
          "id": "benutzbarkeit",
          "label": "Benutzbarkeit",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Benutzbarkeit betrifft Verständlichkeit, Lernbarkeit und effiziente Bedienung.", "correct": true },
            { "id": "w2", "text": "Benutzbarkeit verhindert grundsätzlich Systemausfälle.", "correct": false },
            { "id": "w3", "text": "Ein System kann sehr benutzbar sein, aber trotzdem unzuverlässig (Crashes).", "correct": true },
            { "id": "w4", "text": "UX-Verbesserungen lösen keine Datenverlust-/Uptime-Probleme direkt.", "correct": true }
          ]
        }
      ],
      "solution": "Zuverlässigkeit: Fokus auf Stabilität/Verfügbarkeit/Fehlerrate (Ausfälle und Datenverlust minimieren)."
    },
    {
      "id": "c03",
      "profile": "Nutzer beschweren sich: Die Oberfläche ist verwirrend, Workflows sind unklar, wichtige Funktionen sind schwer zu finden, und ohne Schulung kommt niemand zurecht. Ziel ist, dass Menschen schnell, fehlerarm und gerne damit arbeiten.",
      "tags": ["Benutzbarkeit", "UX", "Ergonomie"],
      "options": [
        {
          "id": "benutzbarkeit",
          "label": "Benutzbarkeit",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Benutzbarkeit betrifft Verständlichkeit, Lernbarkeit und Bedien-Effizienz.", "correct": true },
            { "id": "w2", "text": "Schwer auffindbare Funktionen und hohe Fehlbedienung sind Usability-Themen.", "correct": true },
            { "id": "w3", "text": "Benutzbarkeit bedeutet, dass die Software auf jedes Betriebssystem portierbar ist.", "correct": false },
            { "id": "w4", "text": "Maßnahmen sind z. B. klare UI-Struktur, Feedback, Barrierefreiheit, konsistente Bedienlogik.", "correct": true }
          ]
        },
        {
          "id": "uebertragbarkeit",
          "label": "Übertragbarkeit",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Übertragbarkeit bedeutet Portierbarkeit auf andere Systeme/Umgebungen.", "correct": true },
            { "id": "w2", "text": "Übertragbarkeit löst das Problem „Nutzer finden nichts“ direkt.", "correct": false },
            { "id": "w3", "text": "Eine Software kann portierbar sein und trotzdem schlecht bedienbar.", "correct": true },
            { "id": "w4", "text": "Übertragbarkeit hängt oft an Abhängigkeiten, Plattform APIs und Build/Deploy.", "correct": true }
          ]
        }
      ],
      "solution": "Benutzbarkeit: Verständlichkeit, Lernbarkeit und effiziente Bedienung verbessern (UX/Ergonomie)."
    },
    {
      "id": "c04",
      "profile": "Eine API ist funktional korrekt, aber bei hoher Last werden Antwortzeiten zu lang, CPU-Auslastung steigt, und Infrastrukturkosten explodieren. Ziel: gleiche Funktion, weniger Ressourcen und schnellere Antworten.",
      "tags": ["Effizienz", "Performance", "Ressourcen"],
      "options": [
        {
          "id": "effizienz",
          "label": "Effizienz",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Effizienz betrifft Antwortzeit und Ressourcenverbrauch (CPU, RAM, IO, Netzwerk).", "correct": true },
            { "id": "w2", "text": "Hohe Kosten durch Überlast und Skalierung sind Effizienz-Probleme.", "correct": true },
            { "id": "w3", "text": "Effizienz bedeutet, dass Features vollständig sind.", "correct": false },
            { "id": "w4", "text": "Optimierungen sind z. B. Caching, bessere Algorithmen, Datenbank-Tuning, Profiling.", "correct": true }
          ]
        },
        {
          "id": "funktionalitaet",
          "label": "Funktionalität",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Funktionalität fragt: macht die Software das Richtige?", "correct": true },
            { "id": "w2", "text": "Hier macht sie das Richtige, aber zu langsam/teuer: das ist nicht primär Funktionalität.", "correct": true },
            { "id": "w3", "text": "Funktionalität und Effizienz können gleichzeitig gut oder schlecht sein.", "correct": true },
            { "id": "w4", "text": "Funktionalität löst Performanceprobleme automatisch.", "correct": false }
          ]
        }
      ],
      "solution": "Effizienz: gleiche Funktion bei geringerer Ressourcennutzung und besseren Antwortzeiten."
    },
    {
      "id": "c05",
      "profile": "Nach jeder kleinen Änderung entstehen neue Bugs, Anpassungen dauern lange, und niemand traut sich an den Code. Das System soll leichter weiterentwickelbar sein: sauberer Aufbau, Tests, klare Module und weniger Seiteneffekte.",
      "tags": ["Änderbarkeit", "Wartbarkeit", "Refactoring"],
      "options": [
        {
          "id": "aenderbarkeit",
          "label": "Änderbarkeit",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Änderbarkeit beschreibt, wie leicht Software korrigiert, erweitert und angepasst werden kann.", "correct": true },
            { "id": "w2", "text": "Hohe Bugrate nach Änderungen deutet auf schlechte Wartbarkeit/Änderbarkeit hin.", "correct": true },
            { "id": "w3", "text": "Änderbarkeit bedeutet, dass die Software auf jedem OS läuft.", "correct": false },
            { "id": "w4", "text": "Tests, Modularisierung, klare Architektur und Refactoring verbessern Änderbarkeit.", "correct": true }
          ]
        },
        {
          "id": "uebertragbarkeit",
          "label": "Übertragbarkeit",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Übertragbarkeit zielt auf Portierung zwischen Plattformen/Umgebungen.", "correct": true },
            { "id": "w2", "text": "Sie löst nicht direkt das Problem „Änderung erzeugt neue Bugs“.", "correct": true },
            { "id": "w3", "text": "Eine portierbare Software kann trotzdem schwer wartbar sein.", "correct": true },
            { "id": "w4", "text": "Übertragbarkeit verbessert automatisch Codeverständlichkeit und Tests.", "correct": false }
          ]
        }
      ],
      "solution": "Änderbarkeit: Änderungen sollen schnell, sicher und mit wenig Nebenwirkungen möglich sein (Modularisierung, Tests, saubere Architektur)."
    },
    {
      "id": "c06",
      "profile": "Eine Anwendung soll von Windows auf Linux migriert werden (oder von On-Prem in Container/Cloud). Dabei brechen Abhängigkeiten, Pfade, Systemcalls und Build-Prozesse. Ziel: Software mit wenig Aufwand in andere Umgebungen bringen.",
      "tags": ["Übertragbarkeit", "Portierung", "Plattform"],
      "options": [
        {
          "id": "uebertragbarkeit",
          "label": "Übertragbarkeit",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Übertragbarkeit bedeutet, Software in andere Umgebungen/Plattformen zu bringen.", "correct": true },
            { "id": "w2", "text": "Viele OS-spezifische Abhängigkeiten (Pfade, Systemcalls) senken Übertragbarkeit.", "correct": true },
            { "id": "w3", "text": "Übertragbarkeit ist gleichbedeutend mit „Software ist hübsch zu bedienen“.", "correct": false },
            { "id": "w4", "text": "Standardisierte Schnittstellen, Containerisierung und geringe Plattformkopplung erhöhen Übertragbarkeit.", "correct": true }
          ]
        },
        {
          "id": "zuverlaessigkeit",
          "label": "Zuverlässigkeit",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Zuverlässigkeit betrifft Stabilität/Verfügbarkeit/Fehlerrate im Betrieb.", "correct": true },
            { "id": "w2", "text": "Migration auf ein anderes OS ist primär ein Portierungs-/Kompatibilitätsthema.", "correct": false },
            { "id": "w3", "text": "Eine unzuverlässige Software kann trotzdem portierbar sein, und umgekehrt.", "correct": true },
            { "id": "w4", "text": "Zuverlässigkeit steigt nicht automatisch durch Plattformwechsel.", "correct": true }
          ]
        }
      ],
      "solution": "Übertragbarkeit: Portierung/Kompatibilität zwischen Plattformen (weniger OS-spezifische Abhängigkeiten, standardisierte Schnittstellen)."
    }
  ]
}
