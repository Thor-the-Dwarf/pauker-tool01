{
  "game_type": "matching_puzzle",
  "title": "Speicher (AP1) – HDD • SSD • SATA • NVMe • IOPS • TBW • RAID – Matching",
  "schema_version": "1.0",
  "subtitle": "Ziel: Kombiniere jeweils einen Begriff, die passende Kurzbeschreibung und ein typisches Praxisbeispiel aus AP1-Aufgaben (Systemauswahl, Performance, Verfügbarkeit, Backup).",
  "columnTitles": {
    "column1": "Begriff / Konzept",
    "column2": "Kurzbeschreibung",
    "column3": "Praxisbeispiel"
  },
  "columnHints": {
    "column1": "Wähle einen Begriff oder ein Konzept.",
    "column2": "Wähle die passende Erklärung.",
    "column3": "Ordne ein realistisches Beispiel aus der Prüfung/Praxis zu."
  },
  "sets": [
    {
      "id": "hdd",
      "name": "HDD (Festplatte, mechanisch)",
      "description": "Günstig pro GB und gut für Archiv/Backup-Ziele, aber deutlich langsamer wegen Mechanik (Seek/Rotation).",
      "example": "NAS als Backup-Target: große Datenmengen günstig speichern, Geschwindigkeit ist zweitrangig."
    },
    {
      "id": "ssd_sata",
      "name": "SSD (SATA)",
      "description": "Deutlich schneller als HDD, einfach nachrüstbar, aber durch SATA-Schnittstelle begrenzt.",
      "example": "PC-Upgrade: alte HDD raus, SATA-SSD rein → Boot und Programmstarts spürbar schneller."
    },
    {
      "id": "ssd_nvme",
      "name": "SSD (NVMe)",
      "description": "Sehr hohe IOPS und sehr hoher Datendurchsatz über PCIe; ideal für viele kleine Zugriffe und hohe Last.",
      "example": "Datenbank-VM oder Build-Server: NVMe reduziert Wartezeiten bei vielen Random-Reads/Writes."
    },
    {
      "id": "sata_vs_nvme",
      "name": "SATA vs NVMe",
      "description": "SATA ist langsamer (Schnittstellenlimit), NVMe nutzt PCIe und ist für Parallelität/IO optimiert.",
      "example": "Prüfungsaufgabe: System für viele kleine Dateien/Transaktionen wählen → NVMe statt SATA."
    },
    {
      "id": "iops",
      "name": "IOPS",
      "description": "Messwert für viele kleine Ein-/Ausgabeoperationen pro Sekunde (Random-I/O); wichtig bei DB/VM/Logs.",
      "example": "Ticket-System mit vielen kleinen Datenbankzugriffen: hohe IOPS sind wichtiger als reine MB/s."
    },
    {
      "id": "durchsatz_mbs",
      "name": "Datendurchsatz (MB/s)",
      "description": "Wie schnell große, zusammenhängende Datenblöcke übertragen werden (Sequential); wichtig bei großen Dateien.",
      "example": "Video-Export oder große Backups: hoher Durchsatz zählt, IOPS ist weniger entscheidend."
    },
    {
      "id": "tbw",
      "name": "TBW (Schreibhaltbarkeit)",
      "description": "Angabe, wie viele Terabytes insgesamt geschrieben werden können, bevor die SSD-Haltbarkeit erreicht ist.",
      "example": "Log-Server mit vielen Writes: SSD mit hoher TBW wählen, sonst frühzeitiger Verschleiß."
    },
    {
      "id": "wear_leveling",
      "name": "Wear Leveling",
      "description": "SSD-Mechanismus, der Schreiblast über Speicherzellen verteilt, um Abnutzung gleichmäßig zu halten.",
      "example": "Viele kleine Writes über Jahre: Wear-Leveling hilft, aber TBW bleibt die harte Grenze."
    },
    {
      "id": "trim",
      "name": "TRIM",
      "description": "Befehl, der SSDs hilft, gelöschte Blöcke intern zu markieren und Performance langfristig stabil zu halten.",
      "example": "Nach vielen Lösch-/Schreibzyklen bleibt die SSD reaktionsschnell, wenn TRIM aktiv ist."
    },
    {
      "id": "raid_0",
      "name": "RAID 0 (Striping)",
      "description": "Mehr Performance durch Verteilung auf mehrere Platten, aber keine Redundanz: Ausfall = Datenverlust.",
      "example": "Temporärer Scratch-Speicher für Speed: schnell, aber nur mit Backup/ohne kritische Daten."
    },
    {
      "id": "raid_1",
      "name": "RAID 1 (Mirroring)",
      "description": "Spiegelung: hohe Verfügbarkeit bei Plattenausfall, Kapazität halbiert sich effektiv.",
      "example": "Kleiner Server mit wichtigen Daten: eine Platte darf ausfallen, Betrieb läuft weiter."
    },
    {
      "id": "raid_5",
      "name": "RAID 5 (Parität)",
      "description": "Gute Kapazitätsausnutzung und Ausfallsicherheit (1 Platte), aber Write-Overhead durch Parität.",
      "example": "Dateiserver: viele Reads, moderate Writes; ein Plattenausfall wird toleriert."
    },
    {
      "id": "raid_10",
      "name": "RAID 10 (1+0)",
      "description": "Kombiniert Spiegelung und Striping: sehr gute Performance und Redundanz, braucht mindestens 4 Platten.",
      "example": "VM-Host: viele Random-I/Os, gute Ausfallsicherheit → RAID 10 ist oft der robuste Standard."
    },
    {
      "id": "raid_keine_sicherung",
      "name": "RAID ≠ Backup",
      "description": "RAID erhöht Verfügbarkeit/Performance, schützt aber nicht vor Löschen, Malware, Fehlbedienung oder Brand.",
      "example": "Ransomware verschlüsselt Daten: RAID hilft nicht, nur ein getrenntes Backup rettet."
    },
    {
      "id": "worauf_achten",
      "name": "Worauf achten bei Auswahl?",
      "description": "Use-Case bestimmen: IOPS vs Durchsatz, TBW (Write-Last), Kapazität, Schnittstelle (SATA/NVMe), ggf. RAID/Backup.",
      "example": "Prüfung: Für DB/VM → NVMe + hohe IOPS/TBW; für Archiv → HDD; für Office-PC → SATA-SSD reicht."
    }
  ]
}
