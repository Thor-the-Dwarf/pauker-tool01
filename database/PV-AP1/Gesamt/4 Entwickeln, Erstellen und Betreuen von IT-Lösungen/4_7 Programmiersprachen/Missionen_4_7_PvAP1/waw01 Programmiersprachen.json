{
  "game_type": "what_and_why",
  "title": "What & Why – Programmiersprachen (Grundlagen & Konzepte)",
  "description": "Schritt 1: Passenden Begriff/Konzept wählen (What) · Schritt 2: Zutreffende Begründungen markieren (Why).",
  "cases": [
    {
      "id": "c01",
      "profile": "Du schreibst C-Code. Nach dem Übersetzen liegt Maschinencode in Objektdateien vor, aber am Ende soll eine ausführbare Datei entstehen, die auch externe Bibliotheken einbindet.",
      "tags": ["Compiler", "Linker", "Buildprozess"],
      "options": [
        {
          "id": "linker",
          "label": "Linker",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Verknüpft Objektdateien zu einem ausführbaren Programm oder einer Bibliothek.", "correct": true },
            { "id": "w2", "text": "Löst Symbole/Referenzen auf (z. B. Funktionsaufrufe über Dateien hinweg).", "correct": true },
            { "id": "w3", "text": "Führt den Code Zeile für Zeile zur Laufzeit aus.", "correct": false },
            { "id": "w4", "text": "Bindet Bibliotheken ein (statisch oder dynamisch), damit Aufrufe verfügbar sind.", "correct": true }
          ]
        },
        {
          "id": "interpreter",
          "label": "Interpreter",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Führt Code zur Laufzeit aus, oft ohne separate ausführbare Datei.", "correct": true },
            { "id": "w2", "text": "Ist dafür zuständig, Objektdateien zu einem Executable zu verknüpfen.", "correct": false },
            { "id": "w3", "text": "Kann Fehlermeldungen direkt beim Ausführen liefern.", "correct": true },
            { "id": "w4", "text": "Ersetzt den Linker in klassischen C/C++ Buildprozessen.", "correct": false }
          ]
        }
      ],
      "solution": "Compiler erzeugt Objektcode, der Linker baut daraus das Executable und löst Symbole/Bibliotheken. Interpreter führt Code direkt zur Laufzeit aus."
    },
    {
      "id": "c02",
      "profile": "Du hast ein Python-Skript. Es wird nicht erst zu einer klassischen ausführbaren Datei gelinkt, sondern direkt ausgeführt – Fehler treten oft erst beim Ausführen auf.",
      "tags": ["Interpreter", "Skriptsprache", "Laufzeit"],
      "options": [
        {
          "id": "interpreter",
          "label": "Interpreter",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Führt Code zur Laufzeit aus, statt vorher eine klassische Binary zu erzeugen.", "correct": true },
            { "id": "w2", "text": "Typisch für Skriptsprachen: Ausführen + Fehlermeldungen beim Lauf.", "correct": true },
            { "id": "w3", "text": "Erstellt aus Objektdateien ein Executable und bindet Libraries ein.", "correct": false },
            { "id": "w4", "text": "Braucht oft eine Laufzeitumgebung (Runtime), damit das Programm läuft.", "correct": true }
          ]
        },
        {
          "id": "compiler",
          "label": "Compiler",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Übersetzt Quelltext in Maschinencode/Bytecode, oft vor der Ausführung.", "correct": true },
            { "id": "w2", "text": "Sorgt immer dafür, dass alle Fehler vor dem Start gefunden werden.", "correct": false },
            { "id": "w3", "text": "Ist bei klassischen Sprachen wie C/C++ zentral.", "correct": true },
            { "id": "w4", "text": "Ersetzt Debugging vollständig, weil dann nichts mehr schiefgehen kann.", "correct": false }
          ]
        }
      ],
      "solution": "Interpreter: Ausführung zur Laufzeit (typisch Skriptsprachen). Compiler: Vorab-Übersetzung (Fehler oft früher, aber nicht alle)."
    },
    {
      "id": "c03",
      "profile": "Ein Programm soll extrem einfach sein: Anweisungen laufen nacheinander, Funktionen arbeiten auf Daten, kein Fokus auf Klassen/Objekte. Du willst ein klares, lineares Denken.",
      "tags": ["Prozedural", "Paradigmen"],
      "options": [
        {
          "id": "prozedural",
          "label": "Prozedurale Programmierung",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Fokus liegt auf Funktionen/Prozeduren und einem klaren Ablauf.", "correct": true },
            { "id": "w2", "text": "Daten werden verarbeitet, oft mit Funktionen und globalen/strukturbezogenen Daten.", "correct": true },
            { "id": "w3", "text": "Erfordert zwingend Klassen, Vererbung und Polymorphie.", "correct": false },
            { "id": "w4", "text": "Passt gut für kleine Tools und klar strukturierte Abläufe.", "correct": true }
          ]
        },
        {
          "id": "oop",
          "label": "Objektorientierte Programmierung",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Fokus liegt auf Objekten mit Zustand (Daten) und Verhalten (Methoden).", "correct": true },
            { "id": "w2", "text": "Kann Komplexität strukturieren, wenn viele Entitäten zusammenarbeiten.", "correct": true },
            { "id": "w3", "text": "Ist immer einfacher als prozedural, egal wie klein das Programm ist.", "correct": false },
            { "id": "w4", "text": "Ist nicht zwingend nötig, wenn ein einfacher Ablauf reicht.", "correct": true }
          ]
        }
      ],
      "solution": "Prozedural: Ablauf + Funktionen. OOP: Objekte, Klassen, Methoden. Für einfache lineare Tools reicht oft prozedural."
    },
    {
      "id": "c04",
      "profile": "Du modellierst eine Domäne: Es gibt Personen, Bestellungen, Produkte. Jede Entität hat Daten und Verhalten. Du willst Code wiederverwenden und Beziehungen sauber abbilden.",
      "tags": ["OOP", "Klassen", "Methoden", "Vererbung"],
      "options": [
        {
          "id": "oop",
          "label": "Objektorientierte Programmierung (Klassen/Objekte)",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Klassen bündeln Zustand (Attribute) und Verhalten (Methoden).", "correct": true },
            { "id": "w2", "text": "Vererbung/Interfaces helfen, gemeinsame Eigenschaften wiederzuverwenden.", "correct": true },
            { "id": "w3", "text": "Kontrollstrukturen wie Schleifen sind in OOP nicht erlaubt.", "correct": false },
            { "id": "w4", "text": "Passt gut, wenn viele zusammenhängende „Dinge“ im Code abgebildet werden.", "correct": true }
          ]
        },
        {
          "id": "nur_variablen",
          "label": "Nur Variablen und Funktionen ohne Struktur",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Kann bei kleinen Skripten reichen, skaliert aber schlecht bei komplexen Domänen.", "correct": true },
            { "id": "w2", "text": "Ohne Struktur wird Zustandsverwaltung schnell unübersichtlich.", "correct": true },
            { "id": "w3", "text": "Ist automatisch besser wartbar als Klassen, weil Klassen immer Overkill sind.", "correct": false },
            { "id": "w4", "text": "OOP hilft, Verantwortlichkeiten klar zu kapseln.", "correct": true }
          ]
        }
      ],
      "solution": "Wenn du Domänen-Entitäten modellierst: OOP (Klassen/Methoden/Vererbung). Nur lose Funktionen/Variablen kippen bei Komplexität schnell um."
    },
    {
      "id": "c05",
      "profile": "Du musst eine Aufgabe lösen: Daten einlesen, prüfen, verarbeiten. Du brauchst grundlegende Bausteine: Variablen, Datentypen, Arrays/Listen und Maps/Dictionary.",
      "tags": ["Variablen", "Datentypen", "Datenstrukturen"],
      "options": [
        {
          "id": "datenstrukturen",
          "label": "Variablen, Datentypen und Datenstrukturen (z. B. Liste, Array, Map)",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Datentypen definieren, was gespeichert wird (Zahl, Text, Bool, Objekt).", "correct": true },
            { "id": "w2", "text": "Datenstrukturen organisieren viele Werte (Listen/Arrays) oder Schlüssel-Wert-Paare (Map/Dictionary).", "correct": true },
            { "id": "w3", "text": "Datentypen sind egal, weil jede Sprache automatisch alles korrekt interpretiert.", "correct": false },
            { "id": "w4", "text": "Die Wahl der Struktur beeinflusst Zugriff, Speicher und Komplexität.", "correct": true }
          ]
        },
        {
          "id": "vererbung",
          "label": "Vererbung",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Hilft bei Wiederverwendung und Modellierung von „ist-ein“-Beziehungen.", "correct": true },
            { "id": "w2", "text": "Ist nötig, um überhaupt Zahlen und Strings speichern zu können.", "correct": false },
            { "id": "w3", "text": "Ist optional und nicht der Grundbaustein für einfache Datenverarbeitung.", "correct": true },
            { "id": "w4", "text": "Kann bei falscher Nutzung Komplexität erhöhen (tiefe Hierarchien).", "correct": true }
          ]
        }
      ],
      "solution": "Für Datenverarbeitung brauchst du Variablen/Typen/Strukturen. Vererbung ist ein OOP-Werkzeug, aber nicht der Basisbaustein fürs Einlesen/Verarbeiten."
    },
    {
      "id": "c06",
      "profile": "Ein Programm soll Entscheidungen treffen und wiederholt arbeiten: Wenn X gilt, dann Y; und solange eine Bedingung stimmt, wiederhole eine Aufgabe.",
      "tags": ["Kontrollstrukturen", "Verzweigung", "Schleife"],
      "options": [
        {
          "id": "kontrollstrukturen",
          "label": "Kontrollstrukturen (Verzweigung + Schleifen)",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Verzweigungen (if/switch) steuern, welcher Codepfad ausgeführt wird.", "correct": true },
            { "id": "w2", "text": "Schleifen (for/while) wiederholen Code, bis ein Ziel erreicht ist.", "correct": true },
            { "id": "w3", "text": "Kontrollstrukturen sind nur Deko und ändern nie den Ablauf.", "correct": false },
            { "id": "w4", "text": "Ohne Kontrollstrukturen wäre jedes Programm nur eine starre Abfolge.", "correct": true }
          ]
        },
        {
          "id": "frameworks",
          "label": "Frameworks",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Frameworks liefern Struktur und viele fertige Bausteine (z. B. Web, UI).", "correct": true },
            { "id": "w2", "text": "Ersetzen if/loops vollständig, weil Frameworks den Code für dich schreiben.", "correct": false },
            { "id": "w3", "text": "Kontrollstrukturen bleiben auch mit Frameworks Grundlagen jeder Programmlogik.", "correct": true },
            { "id": "w4", "text": "Frameworks sind hilfreich, aber nicht die Definition von Verzweigungen/Schleifen.", "correct": true }
          ]
        }
      ],
      "solution": "Entscheiden + Wiederholen = Kontrollstrukturen (if/switch, for/while). Frameworks bauen darauf auf, ersetzen es aber nicht."
    },
    {
      "id": "c07",
      "profile": "Du willst Funktionen wie HTTP-Requests, JSON-Parsing oder Datenbankzugriff nutzen, ohne alles selbst zu schreiben. Gleichzeitig soll der Code wartbar bleiben.",
      "tags": ["Bibliotheken", "Frameworks", "Wiederverwendung"],
      "options": [
        {
          "id": "bibliotheken",
          "label": "Bibliotheken (Libraries)",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Stellen wiederverwendbare Funktionen bereit (z. B. HTTP, JSON, Crypto).", "correct": true },
            { "id": "w2", "text": "Reduzieren Eigenaufwand und Fehler, wenn sie gepflegt und etabliert sind.", "correct": true },
            { "id": "w3", "text": "Machen Debugging überflüssig, weil Libraries nie Fehler haben.", "correct": false },
            { "id": "w4", "text": "Integration erfordert Versions-/Kompatibilitätsprüfung (Dependencies).", "correct": true }
          ]
        },
        {
          "id": "frameworks",
          "label": "Frameworks",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Geben oft den Programmrahmen vor (Inversion of Control) und du füllst Bausteine aus.", "correct": true },
            { "id": "w2", "text": "Sind immer besser als Libraries, egal wie klein das Projekt ist.", "correct": false },
            { "id": "w3", "text": "Können viel abnehmen, bringen aber Struktur/Meinungen mit.", "correct": true },
            { "id": "w4", "text": "Libraries sind eher „du rufst sie“, Frameworks „rufen dich“ (Control Flow).", "correct": true }
          ]
        }
      ],
      "solution": "Libraries liefern Funktionen, Frameworks liefern den Rahmen. Beides spart Arbeit, aber du musst Versions-/Kompatibilität und Debugging im Griff haben."
    },
    {
      "id": "c08",
      "profile": "Ein Skript läuft nicht wie erwartet. Du willst schnell herausfinden, wo es klemmt, welche Werte wirklich ankommen, und den Fehler reproduzierbar eingrenzen.",
      "tags": ["Skriptsprachen", "Debugging", "Fehlersuche"],
      "options": [
        {
          "id": "debugging",
          "label": "Debugging (Breakpoints, Logs, Step-by-Step, Variablen prüfen)",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Breakpoints und Step-by-Step zeigen, wo der Ablauf anders läuft als gedacht.", "correct": true },
            { "id": "w2", "text": "Logs/Prints helfen, echte Werte und Zustände sichtbar zu machen.", "correct": true },
            { "id": "w3", "text": "Debugging bedeutet: Code neu schreiben, bis es irgendwie klappt.", "correct": false },
            { "id": "w4", "text": "Reproduzierbarkeit (gleiche Inputs, gleiche Steps) macht Fehlersuche effizient.", "correct": true }
          ]
        },
        {
          "id": "vererbung",
          "label": "Vererbung",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Hilft bei OOP-Struktur, ist aber kein Werkzeug zur Fehlersuche.", "correct": true },
            { "id": "w2", "text": "Löst Laufzeitfehler automatisch, weil Basisklassen alles abfangen.", "correct": false },
            { "id": "w3", "text": "Kann Debugging sogar erschweren, wenn Hierarchien zu komplex werden.", "correct": true },
            { "id": "w4", "text": "Debugging ist unabhängig vom Paradigma (prozedural oder OOP).", "correct": true }
          ]
        }
      ],
      "solution": "Wenn ein Skript spinnt: Debugging (Breakpoints/Step/Logs) und reproduzierbar eingrenzen. Vererbung ist Struktur, kein Diagnosewerkzeug."
    }
  ]
}
