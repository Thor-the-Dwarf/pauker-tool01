{
  "game_type": "matching_puzzle",
  "title": "Programmierung (AP1) – UML • Logik • SQL – Matching",
  "schema_version": "1.0",
  "subtitle": "Ziel: Kombiniere jeweils einen Begriff, die passende Kurzbeschreibung und ein typisches Praxisbeispiel aus AP1-Aufgaben (Modellieren, Algorithmen, SQL, Qualität).",
  "columnTitles": {
    "column1": "Begriff / Konzept",
    "column2": "Kurzbeschreibung",
    "column3": "Praxisbeispiel"
  },
  "columnHints": {
    "column1": "Wähle einen Begriff oder ein Konzept.",
    "column2": "Wähle die passende Erklärung.",
    "column3": "Ordne ein realistisches Beispiel aus der Prüfung/Praxis zu."
  },
  "sets": [
    {
      "id": "anforderung_bis_test",
      "name": "Kette: Anforderungen → Modell → Daten → Test",
      "description": "AP1-Fokus: erst verstehen und modellieren, dann Logik/Daten ableiten, dann Qualität/Test denken.",
      "example": "Aus „Passwort zurücksetzen“ wird Use Case + Aktivität + Tabellen (User, Token) + Tests/Logging."
    },
    {
      "id": "erst_struktur_dann_syntax",
      "name": "Merksatz: Erst Struktur, dann Syntax",
      "description": "Nicht in Code abtauchen, wenn zuerst Modell/Logik/Daten gefragt sind.",
      "example": "Aufgabe verlangt Aktivitätsdiagramm: du lieferst Ablauf + Bedingungen statt direkt Python/Java-Code."
    },
    {
      "id": "use_case",
      "name": "Use-Case-Diagramm",
      "description": "Zeigt, was das System aus Nutzersicht können soll (Fähigkeiten), nicht wie es intern umgesetzt wird.",
      "example": "Actor „Mitarbeiter“ nutzt Use Case „Passwort zurücksetzen“ innerhalb der Systemgrenze."
    },
    {
      "id": "actor",
      "name": "Actor (Rolle)",
      "description": "Actor ist eine Rolle (nicht konkrete Person), die mit dem System interagiert.",
      "example": "„Admin“ statt „Peter“."
    },
    {
      "id": "systemgrenze",
      "name": "Systemgrenze",
      "description": "Abgrenzung: Was gehört ins System, was ist extern? Wichtig für saubere Anforderungen.",
      "example": "E-Mail-Provider liegt außerhalb; das eigene Portal liegt innerhalb der Grenze."
    },
    {
      "id": "use_case_text",
      "name": "Use-Case-Text (Pre → Main → Alt → Post)",
      "description": "Kurzbeschreibung des Use Cases: Vorbedingung, Hauptablauf, Alternativen/Fehlerfälle, Nachbedingung.",
      "example": "Pre: Nutzer identifiziert; Main: Token prüfen; Alt: Token falsch; Post: Passwort geändert + geloggt."
    },
    {
      "id": "klassendiagramm",
      "name": "Klassendiagramm",
      "description": "Zeigt Struktur: Klassen mit Attributen/Methoden sowie Beziehungen.",
      "example": "Klasse „Ticket“ mit Attribut status und Methode schließen()."
    },
    {
      "id": "sichtbarkeit",
      "name": "Sichtbarkeit (public/private)",
      "description": "Legt fest, wer auf Attribute/Methoden zugreifen darf; Teil von sauberem Entwurf.",
      "example": "PasswortHash ist private, resetPassword() ist public."
    },
    {
      "id": "beziehungen_uml",
      "name": "UML-Beziehungen",
      "description": "Assoziation, Aggregation, Komposition, Vererbung – zeigen, wie Klassen zusammenhängen.",
      "example": "Bestellung besteht aus Positionen (Komposition) vs. Kunde hat Bestellungen (Assoziation)."
    },
    {
      "id": "kardinalitaeten_uml",
      "name": "Kardinalitäten (0..1, 1..*, 0..*)",
      "description": "Beschreiben, wie viele Objekte an einer Beziehung beteiligt sein dürfen/müssen.",
      "example": "Kunde 1..* Bestellung; Bestellung 1..* Position."
    },
    {
      "id": "aktivitaetsdiagramm",
      "name": "Aktivitätsdiagramm",
      "description": "Visualisiert Ablauf/Logik mit Aktionen, Entscheidungen, Verzweigungen und Schleifen.",
      "example": "Login prüfen → Entscheidung „gültig?“ → ja: weiter, nein: Fehlermeldung."
    },
    {
      "id": "entscheidung_bedingung",
      "name": "Entscheidung mit Bedingung",
      "description": "Jede Verzweigung braucht eine klare Bedingung, sonst ist sie nicht bewertbar.",
      "example": "Gateway: „Token gültig?“ mit Ja/Nein-Pfad."
    },
    {
      "id": "sequenzdiagramm",
      "name": "Sequenzdiagramm",
      "description": "Zeigt zeitliche Abfolge von Nachrichten/Calls zwischen Komponenten (Zeit von oben nach unten).",
      "example": "UI → Service → DB (Request/Response) für „Ticket erstellen“."
    },
    {
      "id": "zustandsdiagramm",
      "name": "Zustandsdiagramm",
      "description": "Modelliert Zustände und Übergänge eines Objekts über sein „Leben“ hinweg.",
      "example": "Ticket: Neu → Zugewiesen → In Bearbeitung → Gelöst → Geschlossen."
    },
    {
      "id": "zustand_vs_aktion",
      "name": "Zustand ≠ Aktion",
      "description": "Zustand ist eine Phase; Aktionen sind Tätigkeiten innerhalb/zwischen Zuständen.",
      "example": "„Prüfen“ ist Aktion; „In Bearbeitung“ ist Zustand."
    },
    {
      "id": "erd",
      "name": "ERM/ERD (Datenmodell)",
      "description": "Entitäten, Attribute, Beziehungen sowie PK/FK zur relationalen Modellierung.",
      "example": "Entität „Kunde“ (PK), Entität „Bestellung“ (FK auf Kunde)."
    },
    {
      "id": "mn_zwischentabelle",
      "name": "M:N → Zwischentabelle",
      "description": "Many-to-Many wird relational über eine Zwischentabelle sauber gelöst.",
      "example": "Ticket ↔ Tag wird über ticket_tag(ticket_id, tag_id) abgebildet."
    },
    {
      "id": "normalform_1nf",
      "name": "1NF (atomare Werte)",
      "description": "Keine Listen/Mehrfachwerte in einer Spalte; jede Zelle genau ein Wert.",
      "example": "Nicht „skills=HTML,JS“, sondern eigene Tabelle oder Zeilen."
    },
    {
      "id": "normalform_2nf",
      "name": "2NF (volle Abhängigkeit vom PK)",
      "description": "Alle Nicht-Schlüsselattribute hängen vom gesamten Primärschlüssel ab (wichtig bei zusammengesetzten PKs).",
      "example": "In Bestellposition (bestell_id, artikel_id) hängt menge von beiden, nicht nur von einem."
    },
    {
      "id": "normalform_3nf",
      "name": "3NF (keine Transitiven Abhängigkeiten)",
      "description": "Keine Abhängigkeiten zwischen Nicht-Schlüsselattributen; Redundanz vermeiden.",
      "example": "PLZ → Ort wird ausgelagert statt Ort in jeder Kundenzeile zu wiederholen."
    },
    {
      "id": "pseudocode",
      "name": "Pseudocode",
      "description": "Algorithmus/Logik sprachneutral darstellen (If/Else, Schleifen, Variablen) ohne Syntax-Stress.",
      "example": "IF eingabe leer THEN fehler ELSE speichern."
    },
    {
      "id": "pap_flowchart",
      "name": "PAP / Flowchart",
      "description": "Standard-Symbole: Start/Ende, Prozess, Entscheidung, Ein-/Ausgabe – Pfeile zeigen den Ablauf.",
      "example": "Validierung mit Entscheidung „Format ok?“ und Schleife bis gültig."
    },
    {
      "id": "struktogramm",
      "name": "Struktogramm (Nassi–Shneiderman)",
      "description": "Blockbasierte Darstellung (Sequenz, Auswahl, Wiederholung) ohne wilde Sprünge.",
      "example": "IF/ELSE-Block mit WHILE-Block darin für Wiederholversuche."
    },
    {
      "id": "kontrollstrukturen",
      "name": "Kontrollstrukturen",
      "description": "Sequenz (nacheinander), Auswahl (if/else, switch), Schleifen (for/while/do-while) – Konzepte sitzen lassen.",
      "example": "Liste durchsuchen (for), Treffer prüfen (if), bei Fehler erneut fragen (while)."
    },
    {
      "id": "off_by_one",
      "name": "Off-by-one-Fehler",
      "description": "Schleife läuft 1× zu viel/zu wenig: Start, Ende und Abbruchbedingung prüfen.",
      "example": "Index 0..len-1 vs. 1..len führt zu einem Element zu wenig oder IndexError."
    },
    {
      "id": "datentypen",
      "name": "Datentypen & Datenstrukturen",
      "description": "Primitive (Zahl, String, Boolean) und Strukturen (Liste/Array, Dictionary/Map) – Typ bestimmt Verhalten.",
      "example": "‘10’ + ‘2’ ergibt ‘102’ als String, nicht 12."
    },
    {
      "id": "ide_debugger_git_tests",
      "name": "Tools im Entwicklungsalltag",
      "description": "IDE, Debugger, Versionskontrolle (Git), Tests – Hebel für Qualität und Tempo.",
      "example": "Breakpoint setzen, Variablen prüfen, Commit machen, Unit-Tests laufen lassen."
    },
    {
      "id": "logging",
      "name": "Logging (nachvollziehbar, datenschutzkonform)",
      "description": "Ereignisse protokollieren, aber keine sensiblen Daten unnötig loggen.",
      "example": "Log: „Passwort-Reset erfolgreich“ ohne Token/Passwort im Klartext."
    },
    {
      "id": "sql_select_where",
      "name": "SQL-Basics: SELECT + WHERE",
      "description": "Grundstruktur: SELECT … FROM … WHERE …; WHERE vergessen liefert „alles“ und ist oft falsch.",
      "example": "SELECT name FROM users WHERE role = 'admin';"
    },
    {
      "id": "sql_filter_operatoren",
      "name": "SQL-Filter: LIKE / IN / BETWEEN",
      "description": "LIKE für Muster, IN für Listen, BETWEEN für Bereiche; Vergleichsoperatoren für Zahlen/Datum.",
      "example": "SELECT * FROM tickets WHERE status IN ('neu','offen') AND created BETWEEN '2026-01-01' AND '2026-01-31';"
    },
    {
      "id": "sql_order_limit",
      "name": "ORDER BY & LIMIT",
      "description": "ORDER BY sortiert ASC/DESC; LIMIT begrenzt Ergebnisanzahl.",
      "example": "Top 10 neueste Tickets: ORDER BY created DESC LIMIT 10."
    },
    {
      "id": "aggregation_groupby_having",
      "name": "Aggregation & GROUP BY & HAVING",
      "description": "COUNT/SUM/AVG/MIN/MAX; GROUP BY gruppiert; HAVING filtert Gruppen (nicht einzelne Zeilen).",
      "example": "Tickets pro Status zählen und nur Gruppen > 10 zeigen (HAVING COUNT(*) > 10)."
    },
    {
      "id": "joins",
      "name": "JOINs (Schlüsselbezug)",
      "description": "Tabellen über PK/FK verknüpfen; Join ohne Bedingung erzeugt kartesisches Produkt (Datenexplosion).",
      "example": "Tickets mit Kundennamen über ticket.customer_id = customer.id."
    },
    {
      "id": "ddl_dml_dql",
      "name": "SQL: DDL vs DML vs DQL",
      "description": "DDL baut Struktur (CREATE/ALTER/DROP), DML ändert Daten (INSERT/UPDATE/DELETE), DQL fragt ab (SELECT).",
      "example": "CREATE TABLE … (DDL), UPDATE users … (DML), SELECT … (DQL)."
    },
    {
      "id": "update_ohne_where",
      "name": "UPDATE/DELETE ohne WHERE",
      "description": "Ohne WHERE wird alles geändert/gelöscht – in der Prüfung als Fallstrick nennen.",
      "example": "UPDATE users SET role='admin'; macht alle zu Admins."
    },
    {
      "id": "transaktion",
      "name": "Transaktion",
      "description": "Mehrere Schritte als Einheit: entweder alles oder nichts (Commit/Rollback).",
      "example": "User anlegen + Rechte vergeben: klappt nur zusammen, sonst rollback."
    },
    {
      "id": "acid",
      "name": "ACID",
      "description": "Atomicity, Consistency, Isolation, Durability – Kernprinzipien relationaler Transaktionen.",
      "example": "Zwei parallele Updates beeinflussen sich nicht (Isolation) und bleiben nach Stromausfall erhalten (Durability)."
    },
    {
      "id": "db_modelle",
      "name": "Datenbankmodelle (Überblick)",
      "description": "Relational (Tabellen, PK/FK, ACID), Dokument (JSON flexibel), Key-Value (sehr schnell für Lookup/Cache).",
      "example": "Produktivdaten in SQL, Sessions in Key-Value, flexible Logs/Events als Dokumente."
    }
  ]
}
