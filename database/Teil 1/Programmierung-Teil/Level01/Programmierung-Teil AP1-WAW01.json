{
  "game_type": "what_and_why",
  "title": "What & Why – Programmierung (AP1): Modellieren, Logik, SQL",
  "description": "Schritt 1: passendes Modell/Tool bestimmen (What) · Schritt 2: passende Merkmale und Begründungen auswählen (Why).",
  "cases": [
    {
      "id": "v01",
      "profile": "In der Aufgabe sollst du darstellen, was ein System aus Sicht einer Rolle leisten soll (z. B. „Passwort zurücksetzen“). Es geht nicht um Schritte, Algorithmen oder technische Details.",
      "tags": ["UML", "Use Case", "Was"],
      "options": [
        {
          "id": "usecase",
          "label": "Use-Case-Diagramm",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Zeigt Fähigkeiten/Mehrwert aus Sicht von Rollen (Actor), nicht die technische Umsetzung.", "correct": true },
            { "id": "w2", "text": "Beschreibt den Ablauf Schritt für Schritt inklusive Verzweigungen und Schleifen.", "correct": false },
            { "id": "w3", "text": "Hat eine Systemgrenze: Was gehört zum System, was ist extern.", "correct": true },
            { "id": "w4", "text": "Eignet sich primär, um Datenstrukturen mit Attributen und Methoden zu modellieren.", "correct": false }
          ]
        },
        {
          "id": "aktivitaet",
          "label": "Aktivitätsdiagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Visualisiert Abläufe/Workflows mit Entscheidungen (If/Else) und Wiederholungen.", "correct": true },
            { "id": "w2", "text": "Zeigt hauptsächlich, welche Rollen welche System-Fähigkeiten nutzen.", "correct": false },
            { "id": "w3", "text": "Ist geeignet, um den „Happy Path“ und Alternativen als Ablauf darzustellen.", "correct": true },
            { "id": "w4", "text": "Modelliert Zustände eines Objekts über dessen Lebensphasen.", "correct": false }
          ]
        },
        {
          "id": "klasse",
          "label": "Klassendiagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Modelliert Klassen mit Attributen, Methoden und Beziehungen.", "correct": true },
            { "id": "w2", "text": "Zeigt primär die zeitliche Abfolge von Nachrichten zwischen Komponenten.", "correct": false },
            { "id": "w3", "text": "Eignet sich gut, um PK/FK und Tabellenbeziehungen darzustellen.", "correct": false },
            { "id": "w4", "text": "Hilft bei Verantwortlichkeiten: nicht alles in eine Klasse quetschen.", "correct": true }
          ]
        }
      ],
      "solution": "Use-Case-Diagramm: Es geht um „Was kann das System?“ aus Sicht einer Rolle. Schritte/Details gehören in Ablauf-/Logikdiagramme."
    },
    {
      "id": "v02",
      "profile": "Du sollst zeigen, wie ein Prozess/Algorithmus abläuft: Start, Aktionen, Entscheidungen (Ja/Nein), ggf. Schleife. Die Bewertung hängt an klaren Bedingungen.",
      "tags": ["UML", "Logik", "Wie"],
      "options": [
        {
          "id": "aktivitaet",
          "label": "Aktivitätsdiagramm",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Visualisiert Ablauf/Workflow mit klaren Entscheidungen und Verzweigungen.", "correct": true },
            { "id": "w2", "text": "Jede Verzweigung braucht eine beschriftete Bedingung, sonst ist sie kaum bewertbar.", "correct": true },
            { "id": "w3", "text": "Ist dafür da, Datenmodell (Entitäten, Schlüssel) zu zeichnen.", "correct": false },
            { "id": "w4", "text": "Zeigt vor allem Nachrichten über Zeit zwischen UI, Service und DB.", "correct": false }
          ]
        },
        {
          "id": "sequenz",
          "label": "Sequenzdiagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Zeigt die zeitliche Abfolge von Nachrichten zwischen Komponenten.", "correct": true },
            { "id": "w2", "text": "Zeit läuft von oben nach unten, Lifelines sind beteiligte Objekte/Komponenten.", "correct": true },
            { "id": "w3", "text": "Ist das Standarddiagramm für If/Else-Entscheidungen im Ablauf.", "correct": false },
            { "id": "w4", "text": "Eignet sich primär, um Zustände wie „Neu“, „Gelöst“, „Geschlossen“ zu modellieren.", "correct": false }
          ]
        },
        {
          "id": "usecase",
          "label": "Use-Case-Diagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Beschreibt System-Fähigkeiten als Verb + Objekt.", "correct": true },
            { "id": "w2", "text": "Erklärt den detaillierten Algorithmus inklusive Schleifen und Variablen.", "correct": false },
            { "id": "w3", "text": "Actors sind Rollen (z. B. „Mitarbeiter“, „Admin“).", "correct": true },
            { "id": "w4", "text": "Ist für die technische Umsetzung (Wie) gedacht, nicht für Anforderungen.", "correct": false }
          ]
        }
      ],
      "solution": "Aktivitätsdiagramm: Wenn „Wie läuft es ab?“ gefragt ist (Workflow/Logik), ist Aktivität passend. Bedingungen müssen klar dranstehen."
    },
    {
      "id": "v03",
      "profile": "In der Aufgabe sollst du zeigen, welche Komponenten/Objekte miteinander sprechen: UI ruft einen Service, der wiederum die Datenbank abfragt. Es zählt die Reihenfolge der Calls.",
      "tags": ["UML", "Kommunikation", "Zeit"],
      "options": [
        {
          "id": "sequenz",
          "label": "Sequenzdiagramm",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Stellt Nachrichten/Calls in zeitlicher Reihenfolge dar (oben nach unten).", "correct": true },
            { "id": "w2", "text": "Lifelines repräsentieren beteiligte Objekte/Komponenten (z. B. UI, Service, DB).", "correct": true },
            { "id": "w3", "text": "Fokus liegt auf Attributen/Methoden und Beziehungen zwischen Klassen.", "correct": false },
            { "id": "w4", "text": "Ist dafür da, Many-to-Many-Beziehungen mit Zwischentabelle zu lösen.", "correct": false }
          ]
        },
        {
          "id": "klasse",
          "label": "Klassendiagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Zeigt Klassen, Attribute, Methoden und Beziehungen.", "correct": true },
            { "id": "w2", "text": "Kann Kardinalitäten zwischen Klassen darstellen.", "correct": true },
            { "id": "w3", "text": "Zeigt die Reihenfolge von Nachrichten über Zeit zwischen Komponenten.", "correct": false },
            { "id": "w4", "text": "Wird genutzt, um If/Else-Verzweigungen in einem Ablauf zu zeigen.", "correct": false }
          ]
        },
        {
          "id": "zustand",
          "label": "Zustandsdiagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Modelliert Zustände und Übergänge (Trigger/Guard) eines Objekts.", "correct": true },
            { "id": "w2", "text": "Typisch für Lebensphasen wie „Neu“, „In Bearbeitung“, „Geschlossen“. ", "correct": true },
            { "id": "w3", "text": "Zeigt das Gesprächsprotokoll zwischen UI und Service.", "correct": false },
            { "id": "w4", "text": "Zustände sind dasselbe wie Aktionen (z. B. „Prüfen“ ist ein Zustand).", "correct": false }
          ]
        }
      ],
      "solution": "Sequenzdiagramm: Wenn „Wer ruft wen wann?“ gefragt ist, ist Sequenz richtig (zeitlicher Call-Flow zwischen UI/Service/DB)."
    },
    {
      "id": "v04",
      "profile": "Du sollst eine Struktur modellieren: Daten + Verhalten. Es gibt Objekte wie „Kunde“, „Bestellung“, „Position“, inklusive Beziehungen und Kardinalitäten. Es geht nicht um SQL.",
      "tags": ["UML", "Struktur", "Kardinalität"],
      "options": [
        {
          "id": "klasse",
          "label": "Klassendiagramm",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Klasse besteht aus Name, Attributen und Methoden (Daten + Verhalten).", "correct": true },
            { "id": "w2", "text": "Beziehungen und Kardinalitäten zeigen, wie viele Objekte beteiligt sind (z. B. 1..*, 0..*).", "correct": true },
            { "id": "w3", "text": "Ist primär dafür da, SELECT/WHERE/ORDER BY zu üben.", "correct": false },
            { "id": "w4", "text": "„Alles in eine Klasse“ ist guter Stil, weil es übersichtlich bleibt.", "correct": false }
          ]
        },
        {
          "id": "erd",
          "label": "ERM/ERD",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Modelliert Entitäten, Beziehungen, Attribute sowie PK/FK.", "correct": true },
            { "id": "w2", "text": "Fokus ist Datenmodell für relationale Datenbanken.", "correct": true },
            { "id": "w3", "text": "Zeigt Methoden und Sichtbarkeiten (public/private).", "correct": false },
            { "id": "w4", "text": "Eignet sich, um Nachrichten über Zeit zu zeigen (Calls/Rückgaben).", "correct": false }
          ]
        },
        {
          "id": "usecase",
          "label": "Use-Case-Diagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Zeigt Anforderungen als Fähigkeiten (Verb + Objekt).", "correct": true },
            { "id": "w2", "text": "Ist für „Wie läuft der Algorithmus?“ gedacht.", "correct": false },
            { "id": "w3", "text": "Actors sind Rollen und stehen außerhalb der Systemgrenze.", "correct": true },
            { "id": "w4", "text": "Modelliert PK/FK-Schlüssel und Zwischentabellen.", "correct": false }
          ]
        }
      ],
      "solution": "Klassendiagramm: Wenn Daten + Verhalten und Kardinalitäten zwischen Objekten gefragt sind, ist UML-Klasse passend."
    },
    {
      "id": "v05",
      "profile": "Ein Objekt durchläuft klar abgegrenzte Lebensphasen: „Neu“, „Zugewiesen“, „In Bearbeitung“, „Gelöst“, „Geschlossen“. Übergänge passieren durch Ereignisse/Bedingungen.",
      "tags": ["UML", "Zustände", "Übergänge"],
      "options": [
        {
          "id": "zustand",
          "label": "Zustandsdiagramm",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Modelliert Zustände und Übergänge eines Objekts inklusive Trigger/Guard.", "correct": true },
            { "id": "w2", "text": "Zustände sind Lebensphasen, nicht einzelne Aktionen.", "correct": true },
            { "id": "w3", "text": "Eignet sich primär, um SQL-Aggregate (COUNT, SUM, AVG) zu erklären.", "correct": false },
            { "id": "w4", "text": "Übergänge erfolgen typischerweise durch Ereignisse (z. B. „gelöst“).", "correct": true }
          ]
        },
        {
          "id": "aktivitaet",
          "label": "Aktivitätsdiagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Beschreibt Abläufe mit Aktionen, Entscheidungen und Schleifen.", "correct": true },
            { "id": "w2", "text": "Ist ideal, wenn Objekte Lebensphasen mit Zuständen haben.", "correct": false },
            { "id": "w3", "text": "Entscheidungen müssen als Bedingungen beschriftet sein.", "correct": true },
            { "id": "w4", "text": "Modelle werden ohne Start/Ende gezeichnet.", "correct": false }
          ]
        },
        {
          "id": "sequenz",
          "label": "Sequenzdiagramm",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Zeigt Nachrichten zwischen Komponenten über Zeit.", "correct": true },
            { "id": "w2", "text": "Zeit läuft von links nach rechts.", "correct": false },
            { "id": "w3", "text": "Stellt Lifelines für UI/Service/DB dar.", "correct": true },
            { "id": "w4", "text": "Ist das passende Diagramm für Zustandswechsel wie „Neu → Gelöst“.", "correct": false }
          ]
        }
      ],
      "solution": "Zustandsdiagramm: Wenn ein Objekt „Lebensphasen“ hat, modellierst du Zustände und Übergänge (Ereignisse/Guards)."
    },
    {
      "id": "v06",
      "profile": "Du modellierst Daten in Tabellen. Zwischen „Kunde“ und „Auftrag“ gibt es eine Many-to-Many-Beziehung (M:N). Du sollst das relational sauber lösen.",
      "tags": ["Datenmodell", "ERM/ERD", "M:N"],
      "options": [
        {
          "id": "m_n_zwischentabelle",
          "label": "Zwischentabelle (Junction Table) anlegen",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "M:N wird relational über eine eigene Tabelle mit zwei FKs abgebildet.", "correct": true },
            { "id": "w2", "text": "Ohne Zwischentabelle bleibt die Beziehung in SQL-Tabellen unsauber.", "correct": true },
            { "id": "w3", "text": "Die Zwischentabelle braucht keinen Primärschlüssel, weil FKs reichen.", "correct": false },
            { "id": "w4", "text": "Mit der Zwischentabelle kann man zusätzliche Attribute zur Beziehung speichern (z. B. Menge).", "correct": true }
          ]
        },
        {
          "id": "liste_in_spalte",
          "label": "Liste von Auftrag-IDs in einer Spalte speichern",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Verstößt gegen 1NF, weil Mehrfachwerte in einer Zelle landen.", "correct": true },
            { "id": "w2", "text": "Macht UPDATE/DELETE sauberer und verhindert Redundanz.", "correct": false },
            { "id": "w3", "text": "Erschwert Abfragen und erzeugt typische Prüfungs-/Praxisfehler.", "correct": true },
            { "id": "w4", "text": "Ist die Standardlösung im relationalen Modell.", "correct": false }
          ]
        },
        {
          "id": "duplizieren",
          "label": "Aufträge in der Kundentabelle duplizieren",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Erzeugt Redundanz und Update-Anomalien.", "correct": true },
            { "id": "w2", "text": "Macht das Datenmodell automatisch 3NF-konform.", "correct": false },
            { "id": "w3", "text": "Führt bei Änderungen schnell zu inkonsistenten Daten.", "correct": true },
            { "id": "w4", "text": "Ist gut, weil man dann keine Joins mehr braucht.", "correct": false }
          ]
        }
      ],
      "solution": "Zwischentabelle: M:N wird in relationalen Datenbanken über eine eigene Beziehungstabelle gelöst (sauber, abfragbar, erweiterbar)."
    },
    {
      "id": "v07",
      "profile": "In einer Tabelle steht in einer Spalte so etwas wie „Notebooks, Tablets, Tastaturen“ als Komma-Liste. In der Prüfung sollst du erklären, was daran falsch ist und wie man es sauber macht.",
      "tags": ["Normalisierung", "1NF", "Datenqualität"],
      "options": [
        {
          "id": "nf1_verletzung",
          "label": "Verstoß gegen 1. Normalform (1NF)",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "In 1NF muss jede Zelle genau einen atomaren Wert enthalten.", "correct": true },
            { "id": "w2", "text": "Listen/Mehrfachwerte in einer Spalte sind ein klassischer 1NF-Verstoß.", "correct": true },
            { "id": "w3", "text": "Lösung: Werte auslagern (z. B. eigene Tabelle + Beziehung).", "correct": true },
            { "id": "w4", "text": "Das ist erst ab 3NF ein Problem.", "correct": false }
          ]
        },
        {
          "id": "nf2_verletzung",
          "label": "Verstoß gegen 2. Normalform (2NF)",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "2NF: Attribute hängen vom gesamten Primärschlüssel ab, nicht nur von Teilen.", "correct": true },
            { "id": "w2", "text": "2NF betrifft vor allem zusammengesetzte Schlüssel und Teilabhängigkeiten.", "correct": true },
            { "id": "w3", "text": "Komma-Listen in einer Zelle sind das typische 2NF-Kriterium.", "correct": false },
            { "id": "w4", "text": "2NF löst man, indem man Mehrfachwerte in einer Spalte erlaubt.", "correct": false }
          ]
        },
        {
          "id": "nf3_verletzung",
          "label": "Verstoß gegen 3. Normalform (3NF)",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "3NF: Keine Abhängigkeiten zwischen Nicht-Schlüssel-Attributen.", "correct": true },
            { "id": "w2", "text": "3NF zielt auf Redundanz und transitive Abhängigkeiten.", "correct": true },
            { "id": "w3", "text": "Komma-Listen sind automatisch ein 3NF-Verstoß, auch wenn alles atomar ist.", "correct": false },
            { "id": "w4", "text": "3NF bedeutet: Man darf beliebig viele Werte in einer Spalte speichern.", "correct": false }
          ]
        }
      ],
      "solution": "1NF: Komma-Listen sind Mehrfachwerte in einer Zelle. Sauber ist Auslagern in eine eigene Tabelle/Beziehung."
    },
    {
      "id": "v08",
      "profile": "Du sollst einen Algorithmus verständlich darstellen, ohne dich in Syntax zu verlieren. Die Logik soll eindeutig sein (If/Else, Schleifen, Variablen), aber sprachneutral.",
      "tags": ["Programmlogik", "Pseudocode", "Prüfstrategie"],
      "options": [
        {
          "id": "pseudocode",
          "label": "Pseudocode",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Stellt Logik eindeutig dar, ohne an eine konkrete Sprache gebunden zu sein.", "correct": true },
            { "id": "w2", "text": "Ist ideal für Validierung, Suche, Zählen/Summieren, Min/Max.", "correct": true },
            { "id": "w3", "text": "Erfordert korrekte Syntax wie in Python/Java, sonst ist es ungültig.", "correct": false },
            { "id": "w4", "text": "Unklare Bedingungen ohne Definition wirken wie eine wackelige Lösung.", "correct": true }
          ]
        },
        {
          "id": "pap",
          "label": "PAP (Programmablaufplan / Flowchart)",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Visualisiert Algorithmen mit standardisierten Symbolen (Start/Ende, Prozess, Entscheidung).", "correct": true },
            { "id": "w2", "text": "Pfeilrichtung und Schleifen müssen logisch korrekt sein.", "correct": true },
            { "id": "w3", "text": "Ist eine textbasierte Darstellung ohne Symbole.", "correct": false },
            { "id": "w4", "text": "Zwingt zu blockbasierter Struktur ohne Pfeile.", "correct": false }
          ]
        },
        {
          "id": "struktogramm",
          "label": "Struktogramm (Nassi–Shneiderman)",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Blockbasierte Darstellung: Sequenz, Auswahl, Wiederholung als verschachtelte Blöcke.", "correct": true },
            { "id": "w2", "text": "Erzwingt strukturierte Programmierung ohne wilde Sprünge.", "correct": true },
            { "id": "w3", "text": "Ist dafür da, zeitliche Nachrichten zwischen Komponenten zu zeigen.", "correct": false },
            { "id": "w4", "text": "Nutzt typischerweise Pfeile und Rücksprünge statt Blöcke.", "correct": false }
          ]
        }
      ],
      "solution": "Pseudocode: Wenn Logik eindeutig, aber sprachneutral sein soll, nimm Pseudocode (klar benennen, eindeutige Bedingungen)."
    },
    {
      "id": "v09",
      "profile": "Eine Schleife läuft in Tests manchmal genau einmal zu oft oder zu wenig. In der Aufgabe sollst du den typischen Fehler benennen und worauf man achten muss.",
      "tags": ["Kontrollstrukturen", "Schleifen", "Fehlerquelle"],
      "options": [
        {
          "id": "off_by_one",
          "label": "Off-by-one-Fehler",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Passiert, wenn Start/Ende/Abbruchbedingung falsch gesetzt sind (±1).", "correct": true },
            { "id": "w2", "text": "Typisch bei Indexgrenzen und Schleifenbedingungen.", "correct": true },
            { "id": "w3", "text": "Hat nichts mit Grenzen zu tun, sondern nur mit Datentypen.", "correct": false },
            { "id": "w4", "text": "Prüfpunkt: Grenze prüfen (Start, Ende, Abbruchbedingung).", "correct": true }
          ]
        },
        {
          "id": "type_confusion",
          "label": "Typ-Verwechslung (String vs Zahl)",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Kann zu falschen Ergebnissen führen (z. B. '10' + '2' ist nicht 12).", "correct": true },
            { "id": "w2", "text": "Ist die Standardursache dafür, dass eine Schleife 1× zu viel läuft.", "correct": false },
            { "id": "w3", "text": "Typ bestimmt Verhalten und Operationen.", "correct": true },
            { "id": "w4", "text": "Betrifft vor allem Operatoren und Casting/Parsing.", "correct": true }
          ]
        },
        {
          "id": "join_cartesian",
          "label": "Kartesisches Produkt (Join ohne Bedingung)",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Entsteht, wenn Tabellen ohne Schlüsselbezug kombiniert werden.", "correct": true },
            { "id": "w2", "text": "Führt zu Datenexplosion und ist fast immer falsch.", "correct": true },
            { "id": "w3", "text": "Ist ein typischer Schleifen-Grenzen-Fehler.", "correct": false },
            { "id": "w4", "text": "Hat mit SQL und Joins zu tun, nicht mit Schleifenbedingungen.", "correct": true }
          ]
        }
      ],
      "solution": "Off-by-one: Schleife läuft ±1 falsch. Prüfpunkt ist immer Startwert, Endwert und Abbruchbedingung (Indexgrenzen!)."
    },
    {
      "id": "v10",
      "profile": "Eine SQL-Auswertung liefert plötzlich „alles“. In der Aufgabe geht’s um den typischen Fehler bei Abfragen – und warum das in der Prüfung fast immer falsch ist.",
      "tags": ["SQL", "SELECT", "WHERE"],
      "options": [
        {
          "id": "where_fehlt",
          "label": "WHERE fehlt oder ist falsch",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Ohne WHERE wird nicht gefiltert – Ergebnis enthält alle Zeilen.", "correct": true },
            { "id": "w2", "text": "Ist eine typische Prüfungsfalle: „alles liefern“ statt die geforderte Teilmenge.", "correct": true },
            { "id": "w3", "text": "ORDER BY ersetzt WHERE, weil Sortierung auch filtert.", "correct": false },
            { "id": "w4", "text": "Bei UPDATE/DELETE ohne WHERE wird es besonders kritisch.", "correct": true }
          ]
        },
        {
          "id": "order_by_fehlt",
          "label": "ORDER BY fehlt",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "ORDER BY sortiert Ergebnisse, filtert aber nicht.", "correct": true },
            { "id": "w2", "text": "Fehlt ORDER BY, ist die Reihenfolge oft nicht garantiert.", "correct": true },
            { "id": "w3", "text": "Wenn ORDER BY fehlt, werden automatisch alle Datensätze zurückgegeben.", "correct": false },
            { "id": "w4", "text": "LIMIT begrenzt Anzahl, ersetzt aber keine Filterlogik.", "correct": true }
          ]
        },
        {
          "id": "group_by_fehlt",
          "label": "GROUP BY fehlt",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "GROUP BY wird benötigt, wenn du pro Gruppe aggregieren willst (z. B. COUNT pro Status).", "correct": true },
            { "id": "w2", "text": "HAVING filtert Gruppen nach Aggregat, WHERE filtert vorher.", "correct": true },
            { "id": "w3", "text": "Fehlendes GROUP BY erklärt, warum SELECT ohne Filter „alles“ liefert.", "correct": false },
            { "id": "w4", "text": "GROUP BY ist unabhängig davon, ob überhaupt gefiltert werden soll.", "correct": true }
          ]
        }
      ],
      "solution": "WHERE fehlt/falsch: Ohne Filter bekommst du alle Zeilen. In Prüfungen ist das meist ein klarer Punktverlust – und bei UPDATE/DELETE brandgefährlich."
    },
    {
      "id": "v11",
      "profile": "Jemand verbindet zwei Tabellen, aber nennt keine Join-Bedingung über Schlüssel (PK/FK). Das Ergebnis wird riesig und unsinnig. Du sollst den Fehler benennen.",
      "tags": ["SQL", "Join", "PK/FK"],
      "options": [
        {
          "id": "kartesisch",
          "label": "Kartesisches Produkt (Join ohne Bedingung)",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "Ohne Schlüsselbezug werden alle Kombinationen der Zeilen gebildet.", "correct": true },
            { "id": "w2", "text": "Das führt zu Datenexplosion und ist fast nie gewollt.", "correct": true },
            { "id": "w3", "text": "Korrekt ist Join über PK/FK (Join-Bedingung), sonst ist das Ergebnis falsch.", "correct": true },
            { "id": "w4", "text": "Passiert nur bei LEFT JOIN, bei INNER JOIN nie.", "correct": false }
          ]
        },
        {
          "id": "inner_join",
          "label": "INNER JOIN (nur passende Datensätze)",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Liefert nur Datensätze, die in beiden Tabellen passen.", "correct": true },
            { "id": "w2", "text": "Braucht trotzdem eine Join-Bedingung über Schlüssel.", "correct": true },
            { "id": "w3", "text": "Erzeugt immer automatisch alle Kombinationen, auch ohne Bedingung.", "correct": false },
            { "id": "w4", "text": "Ist das Gegenteil von LEFT JOIN (alles von links).", "correct": true }
          ]
        },
        {
          "id": "left_join",
          "label": "LEFT JOIN (alles von links, rechts wenn vorhanden)",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Liefert alle Datensätze der linken Tabelle, plus passende aus der rechten.", "correct": true },
            { "id": "w2", "text": "Ist nützlich, wenn rechts optional ist.", "correct": true },
            { "id": "w3", "text": "Ist die Ursache, dass ohne Join-Bedingung ein Kartesisches Produkt entsteht.", "correct": false },
            { "id": "w4", "text": "Auch hier gilt: Join-Bedingung über PK/FK ist Pflicht für sinnvolle Ergebnisse.", "correct": true }
          ]
        }
      ],
      "solution": "Kartesisches Produkt: Join ohne Schlüsselbezug erzeugt alle Kombinationen. Richtiger Join braucht eine Bedingung über PK/FK."
    },
    {
      "id": "v12",
      "profile": "In einer Aufgabe sollst du einordnen: „CREATE TABLE“, „INSERT“, „SELECT“. Es geht um die richtigen Kategorien (Struktur, Daten ändern, Daten abfragen).",
      "tags": ["SQL", "DDL", "DML", "DQL"],
      "options": [
        {
          "id": "ddl_dml_dql",
          "label": "DDL / DML / DQL korrekt unterscheiden",
          "isCorrect": true,
          "whys": [
            { "id": "w1", "text": "DDL: CREATE/ALTER/DROP – baut/ändert die Struktur (Tabellen, Spalten).", "correct": true },
            { "id": "w2", "text": "DML: INSERT/UPDATE/DELETE – fügt/ändert/löscht Daten.", "correct": true },
            { "id": "w3", "text": "DQL: SELECT – fragt Daten ab.", "correct": true },
            { "id": "w4", "text": "UPDATE gehört zu DDL, weil es die Struktur verändert.", "correct": false }
          ]
        },
        {
          "id": "transaktion",
          "label": "Transaktion & ACID erklären",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "Transaktion: mehrere Schritte als unteilbare Einheit (alles oder nichts).", "correct": true },
            { "id": "w2", "text": "ACID: Atomicity, Consistency, Isolation, Durability.", "correct": true },
            { "id": "w3", "text": "ACID beschreibt UML-Diagrammtypen für Modellierung.", "correct": false },
            { "id": "w4", "text": "„Speichern“ ist nicht automatisch gleich „Transaktion abgeschlossen“.", "correct": true }
          ]
        },
        {
          "id": "group_by",
          "label": "Aggregation & GROUP BY einsetzen",
          "isCorrect": false,
          "whys": [
            { "id": "w1", "text": "COUNT/SUM/AVG/MIN/MAX fassen mehrere Datensätze zu einem Wert zusammen.", "correct": true },
            { "id": "w2", "text": "GROUP BY gruppiert vor der Aggregation (z. B. COUNT pro Status).", "correct": true },
            { "id": "w3", "text": "HAVING filtert vor GROUP BY, WHERE filtert nach Aggregation.", "correct": false },
            { "id": "w4", "text": "HAVING filtert Gruppen nach Aggregat (anders als WHERE).", "correct": true }
          ]
        }
      ],
      "solution": "DDL/DML/DQL: CREATE/ALTER/DROP = Struktur (DDL), INSERT/UPDATE/DELETE = Daten ändern (DML), SELECT = Daten abfragen (DQL)."
    }
  ]
}
