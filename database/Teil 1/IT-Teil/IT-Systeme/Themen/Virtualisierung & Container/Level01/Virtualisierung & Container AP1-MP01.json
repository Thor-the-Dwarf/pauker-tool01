{
  "game_type": "matching_puzzle",
  "title": "Virtualisierung & Container (AP1) – VM • Hypervisor • Container • Kernel-Sharing • Nutzen – Matching",
  "schema_version": "1.0",
  "subtitle": "Ziel: Kombiniere jeweils einen Virtualisierungs-/Container-Begriff, die passende Kurzbeschreibung und ein typisches Praxisbeispiel aus AP1-Aufgaben (Einordnung, Nutzen, Auswahl).",
  "columnTitles": {
    "column1": "Begriff / Konzept",
    "column2": "Kurzbeschreibung",
    "column3": "Praxisbeispiel"
  },
  "columnHints": {
    "column1": "Wähle einen Virtualisierungs- oder Container-Begriff.",
    "column2": "Wähle die passende Erklärung.",
    "column3": "Ordne ein realistisches Beispiel aus der Prüfung/Praxis zu."
  },
  "sets": [
    {
      "id": "virtualisierung",
      "name": "Virtualisierung (Grundidee)",
      "description": "Mehrere logische Systeme laufen auf einer physischen Hardware; Ressourcen werden zugeteilt und isoliert.",
      "example": "Ein Server hostet mehrere getrennte Systeme für Web, DB und Test statt drei separater Rechner."
    },
    {
      "id": "vm",
      "name": "Virtuelle Maschine (VM)",
      "description": "Jede VM hat ein eigenes vollständiges Betriebssystem; läuft auf virtualisierter Hardware; hohe Isolation, aber mehr Overhead.",
      "example": "Für ein Legacy-System wird eine VM mit eigenem OS betrieben, damit es sauber getrennt bleibt."
    },
    {
      "id": "hypervisor",
      "name": "Hypervisor",
      "description": "Schicht, die VMs verwaltet und Hardware-Ressourcen (CPU/RAM/Storage/Netz) zuteilt; Basis der VM-Virtualisierung.",
      "example": "Du legst eine VM an, gibst 4 vCPU und 8 GB RAM und startest sie über den Hypervisor."
    },
    {
      "id": "vm_isolation",
      "name": "VM-Isolation (stark)",
      "description": "VMs sind durch eigenes OS und virtuelle Hardware stark voneinander getrennt; Sicherheits- und Stabilitätsvorteil.",
      "example": "Eine kompromittierte VM soll nicht direkt den Host oder andere VMs mitreißen."
    },
    {
      "id": "vm_overhead",
      "name": "VM-Overhead (höher)",
      "description": "Mehr Ressourcenverbrauch durch eigenes OS pro VM (Boot, Updates, RAM-Bedarf); Start/Provisioning langsamer als Container.",
      "example": "Für 10 kleine Dienste wären 10 VMs zu schwergewichtig: zu viel RAM und Admin-Aufwand."
    },
    {
      "id": "container",
      "name": "Container",
      "description": "Pakete aus App + Abhängigkeiten; teilen sich den Kernel des Hosts; leichtgewichtig, schnell startbar.",
      "example": "Webservice läuft im Container und startet in Sekunden statt Minuten wie eine VM."
    },
    {
      "id": "kernel_sharing",
      "name": "Kernel-Sharing",
      "description": "Container nutzen denselben Host-Kernel; dadurch weniger Overhead, aber andere Isolationsgrenzen als bei VMs.",
      "example": "Linux-Container laufen direkt auf Linux-Host, weil der Kernel gemeinsam genutzt wird."
    },
    {
      "id": "container_isolation",
      "name": "Container-Isolation (anders)",
      "description": "Isolation primär über Namespaces/Policies; weniger „hart“ als getrennte OS-Instanzen, abhängig von Konfiguration und Runtime.",
      "example": "Mehrere Container teilen Kernel: Fehlkonfiguration kann zu unerwarteten Zugriffen/Leaks führen."
    },
    {
      "id": "use_case_vm_vs_container",
      "name": "Wann VM, wann Container?",
      "description": "VMs: wenn starke Isolation oder anderes OS nötig ist. Container: wenn schnelle Deployments und viele kleine Dienste gefragt sind.",
      "example": "Windows-App in VM, Linux-Webservices als Container auf demselben Host."
    },
    {
      "id": "bessere_auslastung",
      "name": "Nutzen: bessere Auslastung",
      "description": "Ressourcen werden dynamischer genutzt; weniger „idle Hardware“, mehr Workloads pro Server möglich.",
      "example": "Statt 5 halb-leerer Server laufen 5 Dienste konsolidiert auf 1–2 Hosts."
    },
    {
      "id": "schnelles_deployment",
      "name": "Nutzen: schnelles Deployment",
      "description": "Schneller ausrollen/ersetzen, weil Images/Container standardisiert sind; reduziert „läuft nur auf meinem Rechner“-Probleme.",
      "example": "Neues Release: altes Container-Image ersetzen, Dienst startet sofort mit gleicher Konfiguration."
    },
    {
      "id": "testbare_umgebung",
      "name": "Nutzen: testbare Umgebungen",
      "description": "Reproduzierbare Test-Stacks (z.B. App + DB) lassen sich schnell aufsetzen und wieder löschen.",
      "example": "Für eine Aufgabe baust du eine Testumgebung mit Web + DB, testest und wirfst sie danach weg."
    },
    {
      "id": "snapshot_rollback",
      "name": "Snapshot/Rollback (typisch VM)",
      "description": "VMs lassen sich oft per Snapshot sichern und schnell zurücksetzen; praktisch für Tests und Fehlersuche.",
      "example": "Vor Update Snapshot ziehen, Update testen, bei Problemen zurückrollen."
    },
    {
      "id": "merksatz_ap1",
      "name": "AP1-Merksatz",
      "description": "VM = eigenes OS, stärker getrennt, schwerer. Container = Kernel teilen, schneller/leichter, Isolation anders. Nutzen = Auslastung + Deployment + Tests.",
      "example": "Kurzbegründung in einer AP1-Aufgabe: Warum Container für Dev/Test, warum VM für harte Trennung/anderes OS."
    }
  ]
}
